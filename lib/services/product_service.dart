import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/product_model.dart';

/// Product Service for store inventory management (Supabase Backed)
/// Products are added by Store Managers - no hardcoded data
class ProductService {
  static final ProductService _instance = ProductService._internal();
  factory ProductService() => _instance;
  ProductService._internal();

  final _supabase = Supabase.instance.client;

  /// Get products for a specific store (Real-time or Cached)
  Future<List<ProductModel>> getProductsByStore(String storeId) async {
    try {
      final response = await _supabase
          .from('products')
          .select()
          .eq('store_id', storeId)
          .order('name', ascending: true);

      return (response as List)
          .map((json) => ProductModel.fromJson(json))
          .toList();
    } catch (e) {
      print('Error fetching products: $e');
      // Return empty list on error
      return [];
    }
  }

  /// Get product by barcode
  Future<ProductModel?> getProductByBarcode(
    String storeId,
    String barcode,
  ) async {
    try {
      final response = await _supabase
          .from('products')
          .select()
          .eq('store_id', storeId)
          .eq('barcode', barcode)
          .maybeSingle();

      if (response != null) {
        return ProductModel.fromJson(response);
      }
      return null;
    } catch (e) {
      print('Error fetching product: $e');
      return null;
    }
  }

  /// Add a new product (Store Manager function)
  Future<ProductModel> addProduct(ProductModel product) async {
    try {
      // Prepare data
      final data = product.toJson();
      // Remove local ID to let DB generate one?
      // Our model requires ID, but let's assume if it's new we let Supabase handle it
      // OR we just use UUID generated by model if it's robust.
      // SQL schema says: id UUID DEFAULT uuid_generate_v4()
      // So best practice is to OMIT id if meaningful, or send it if we generated a valid UUID locally.
      // ProductModel constructor *requires* ID. Let's see if we can use the model's ID if valid UUID
      // or just send without ID.
      // But toJson includes ID.
      // Let's rely on client-side UUID generation for optimistic UI updates usually,
      // but simpler to let DB generate and we fetch back.
      // However, ProductModel is immutable.
      // Let's try sending everything. If Model ID is random string, Postgres might reject if not UUID.
      // ProductModel generates 'prod_${DateTime...}' which is NOT UUID.
      // We must OMIT 'id' from insert and let Postgres generate UUID.

      final dbData = {
        'store_id': product.storeId,
        'name': product.name,
        'description': product.description,
        'price': product.price,
        'category': product.category,
        'stock_quantity': product.stockQuantity,
        'barcode': product.barcode,
        'image_url': product.imageUrl,
      };

      final response = await _supabase
          .from('products')
          .insert(dbData)
          .select()
          .single();
      return ProductModel.fromJson(response);
    } catch (e) {
      print('Error adding product: $e');
      throw Exception('Failed to add product: $e');
    }
  }

  /// Update a product
  Future<void> updateProduct(ProductModel product) async {
    try {
      await _supabase
          .from('products')
          .update({
            'name': product.name,
            'description': product.description,
            'price': product.price,
            'category': product.category,
            'stock_quantity': product.stockQuantity,
            'image_url': product.imageUrl,
          })
          .eq('id', product.id);
    } catch (e) {
      print('Error updating product: $e');
      throw Exception('Failed to update product');
    }
  }

  /// Delete a product
  Future<void> deleteProduct(String storeId, String productId) async {
    try {
      await _supabase
          .from('products')
          .delete()
          .eq('id', productId)
          .eq('store_id', storeId); // Safety check
    } catch (e) {
      print('Error deleting product: $e');
      throw Exception('Failed to delete product');
    }
  }

  /// Update stock quantity (reduce after purchase)
  Future<void> reduceStock(
    String storeId,
    String productId,
    int quantity,
  ) async {
    try {
      // We should ideally use an RPC/Function for atomic updates
      // But for now, read-then-write or basic decrement.
      // Supabase supports rpc? Or just a simple update if we trust client state?
      // Let's use current value from DB to be safe-ish.

      final current = await _supabase
          .from('products')
          .select('stock_quantity')
          .eq('id', productId)
          .single();

      final int currentStock = current['stock_quantity'] as int;
      final newStock = (currentStock - quantity).clamp(0, 999999);

      await _supabase
          .from('products')
          .update({'stock_quantity': newStock})
          .eq('id', productId);
    } catch (e) {
      print('Error reducing stock: $e');
    }
  }

  /// Search products in a store
  Future<List<ProductModel>> searchProducts(
    String storeId,
    String query,
  ) async {
    if (query.isEmpty) return getProductsByStore(storeId);

    try {
      // Search by name or category or barcode
      final response = await _supabase
          .from('products')
          .select()
          .eq('store_id', storeId)
          .or('name.ilike.%$query%,category.ilike.%$query%,barcode.eq.$query');

      return (response as List)
          .map((json) => ProductModel.fromJson(json))
          .toList();
    } catch (e) {
      print('Search error: $e');
      return [];
    }
  }

  /// Get low stock products
  Future<List<ProductModel>> getLowStockProducts(
    String storeId, {
    int threshold = 10,
  }) async {
    try {
      final response = await _supabase
          .from('products')
          .select()
          .eq('store_id', storeId)
          .lte('stock_quantity', threshold);

      return (response as List)
          .map((json) => ProductModel.fromJson(json))
          .toList();
    } catch (e) {
      print('Error fetching low stock: $e');
      return [];
    }
  }

  /// Get product categories for a store
  Future<List<String>> getCategories(String storeId) async {
    try {
      // Fetch distinct categories?
      // Supabase JS SDK has .distinct() but Flutter simplified query needed.
      // Just fetch all products (cached/limit?) or use an RPC if scale is huge.
      // For prototype, fetching all names/categories is fine.
      final response = await _supabase
          .from('products')
          .select('category')
          .eq('store_id', storeId);

      final categories =
          (response as List)
              .map((item) => item['category'] as String)
              .toSet()
              .toList()
            ..sort();

      return categories;
    } catch (e) {
      return [];
    }
  }
}
